@using Rudzoft.ChessLib.Types
@using Domain.DTOs
@using Rudzoft.ChessLib
@using Rudzoft.ChessLib.MoveGeneration
@namespace BlazorWASM.Pages.ChessComponents

<div class="chess-board @(!IsWhiteSide ? "black-side" : "")">
    
@{
    var index = 0;
    var isBlackSquare = _isFirstSquareBlack;
    _currentPieces = ParsePositionToPieces();
    var kingSquareInCheck = KingSquareInCheck();

    for (var rank = Ranks.Rank8; rank >= Ranks.Rank1; rank--)
    {
        for (var file = Files.FileA; file <= Files.FileH; file++)
        {
            isBlackSquare = !isBlackSquare;
            var squareId = new Square(rank,file).Value;
            var hasMoveTo = _currentMoves.Any(move => move.ToSquare() == squareId && move.IsValidMove());
            <SquareComponent
                SquareId="@squareId"
                HasMoveTo="@hasMoveTo"
                IsBlackSquare="@isBlackSquare"
                Piece="@_currentPieces[index]"
                OnClick="@OnSquareClicked"
                IsWhiteSide="@IsWhiteSide"
                IsKingCheck="@(kingSquareInCheck == squareId)"
            />

            index++;
        }
        isBlackSquare = !isBlackSquare;
    }
}

</div>

@code {
    [Parameter] 
    public IPosition? Position { get; set; }

    [Parameter] 
    public EventCallback<Move> OnMoveMade { get; set; }
    
    [Parameter]
    public bool IsWhiteSide { get; set; }

    private List<Piece> _currentPieces = EmptyList<Piece>();
    private List<Move> _currentMoves = EmptyList<Move>();
    private bool _isFirstSquareBlack = true;

    // Lists need to have values initialized to null to avoid Index out of bounds exception while rendering the chessboard. 
    private static List<T> EmptyList<T>(int initialSize = 64)
    {
        return new List<T>(new T[initialSize]);
    }

    private Square KingSquareInCheck()
    {
        if (Position is {InCheck: true })
            return Position.GetKingSquare(Position.SideToMove);
        
        return Square.None;
    }
    

    private List<Piece> ParsePositionToPieces()
    {
        List<Piece> chessPieces = EmptyList<Piece>();
     
        if (Position == null)
            return chessPieces;
        
        var index = 0;
        
        for (var rank = Ranks.Rank8; rank >= Ranks.Rank1; rank--)
        {
            for (var file = Files.FileA; file <= Files.FileH; file++)
            {
                var piece = Position.GetPiece(new Square(rank, file));
                
                chessPieces[index] =  piece;
                
                index++;
            }
        }
        return chessPieces;
    }
    
    private List<Move> GenerateMovesForSquare(ChessClickDto dto)
    {
        return Position
            .GenerateMoves()
            .ToList()
            .FindAll(move => move.Move.FromSquare() == dto.SquareType)
            .Select(move => move.Move).ToList();
    }
    
    private void OnSquareClicked(ChessClickDto dto)
    {
        if (dto.HasMoveTo)
        {
            MakeMove(dto);
            return;            
        }
        
        if (dto.PieceType != Pieces.NoPiece)
        {
            _currentMoves = GenerateMovesForSquare(dto);
        }
    }
    
    private void MakeMove(ChessClickDto dto)
    {
        var move = _currentMoves.Find(move => move.ToSquare() == dto.SquareType);
        OnMoveMade.InvokeAsync(move);
        _currentMoves = EmptyList<Move>();
    }
}