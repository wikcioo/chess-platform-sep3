@page "/ChessGame"
@using Rudzoft.ChessLib.Types
@using Rudzoft.ChessLib
@using Rudzoft.ChessLib.Enums
@using Rudzoft.ChessLib.Fen
@using Application.LogicInterfaces
@using Position = Rudzoft.ChessLib.Position
@using Domain.DTOs
@using Domain.Enums
@using Grpc.Core
@using BlazorWASM.Pages.ChessComponents
@using System.Security.Claims
@using Domain.Models
@inject IDialogService DialogService
@inject IJSRuntime Js
@inject ISnackbar Snackbar
@inject IGameLogic GameLogic
@inject IChatLogic ChatLogic
@implements IDisposable


<audio id="move" src="sounds/move.mp3"></audio>
<audio id="notify" src="sounds/notify.mp3"></audio>

<MudButton @onclick="Resign" Variant="Variant.Filled" Color="Color.Primary">Resign</MudButton>
<MudButton @onclick="OfferDraw" Variant="Variant.Filled" Color="Color.Primary">Offer Draw</MudButton>
@if (GameLogic.IsDrawOfferPending)
{
    <div>
        <h3>You have a draw offer</h3>
        <MudButton @onclick="() => SendDrawResponse(true)" Variant="Variant.Filled" Color="Color.Success">Accept</MudButton>
        <MudButton @onclick="() => SendDrawResponse(false)" Variant="Variant.Filled" Color="Color.Error">Decline</MudButton>
    </div>
}

<MudGrid Justify="Justify.SpaceAround" Spacing="10">
    <MudItem xs="12" lg="6">
        <TimerComponent Active="@(_isWhiteSide == GameSides.White ? !_whiteTimerActive : _whiteTimerActive)"
                        Seconds="@(_isWhiteSide == GameSides.White ? _blackSeconds : _whiteSeconds)"/>
        <ChessBoardComponent OnMoveMade="MakeMove" Position="@_position" IsWhiteSide="@(_isWhiteSide == GameSides.White)"/>
        <TimerComponent Active="@(_isWhiteSide == GameSides.White ? _whiteTimerActive : !_whiteTimerActive)"
                        Seconds="@(_isWhiteSide == GameSides.White ? _whiteSeconds : _blackSeconds)"/>
    </MudItem>
    <MudItem xs="12" lg="6">
        <ChatWindow GameRoom="@GameLogic.GameRoomId"></ChatWindow>
    </MudItem>
</MudGrid>

@code {

    [CascadingParameter]
    public Task<AuthenticationState> AuthState { get; set; } = null!;

    private string _currentUser = "";

    private readonly IPosition _position = new Position(new Board(), new PieceValue());
    private double _whiteSeconds;
    private double _blackSeconds;
    private bool _whiteTimerActive = true;

    //Form input bindings
    private string _selectedLevel = StockfishLevels.StockfishAi1.Value;
    private OpponentTypes _opponentType = OpponentTypes.Ai;
    private ulong _gameRoomInt;
    private GameSides _isWhiteSide = GameSides.White;
    private string _opponentName = "";
    private uint _timeControlBase = 120;
    private uint _timeControlIncrement;
    private bool _isGamePrivate;

    protected override void OnInitialized()
    {
        SetFenPosition(Fen.StartPositionFen);
        InitGameLogic();
    }

    public void Dispose()
    {
        GameLogic.TimeUpdated -= OnTimeUpdated;
        GameLogic.NewFenReceived -= OnNewFenReceived;
        GameLogic.ResignationReceived -= OnResignationReceived;
        GameLogic.InitialTimeReceived -= OnInitialTimeReceived;
        GameLogic.DrawOffered -= OnDrawOffered;
        GameLogic.DrawOfferTimedOut -= OnDrawOfferTimedOut;
        GameLogic.DrawOfferAccepted -= OnDrawOfferAccepted;
        GameLogic.EndOfTheGameReached -= OnEndOfTheGameReached;
        GameLogic.GameFirstJoined -= OnGameFirstJoined;
    }

    protected override async Task OnInitializedAsync()
    {
        AuthenticationState authState = await AuthState;
        ClaimsPrincipal user = authState.User;
        if (user.Identity == null) return;
        _currentUser = user.Identity.Name!;
    }

    private void InitGameLogic()
    {
        GameLogic.TimeUpdated += OnTimeUpdated;
        GameLogic.NewFenReceived += OnNewFenReceived;
        GameLogic.ResignationReceived += OnResignationReceived;
        GameLogic.InitialTimeReceived += OnInitialTimeReceived;
        GameLogic.DrawOffered += OnDrawOffered;
        GameLogic.DrawOfferTimedOut += OnDrawOfferTimedOut;
        GameLogic.DrawOfferAccepted += OnDrawOfferAccepted;
        GameLogic.EndOfTheGameReached += OnEndOfTheGameReached;
        GameLogic.GameFirstJoined += OnGameFirstJoined;
    }

    public async Task<int> MakeMove(Move move)
    {
        try
        {
            var t = await GameLogic.MakeMove(move);
            _whiteTimerActive = !_whiteTimerActive;
            return t;

        }
        catch (InvalidOperationException e)
        {
            Notify(e.Message, Severity.Warning);
            return (int)AckTypes.GameNotFound;
        }
    }

    private async void Resign()
    {
        AckTypes ack;
        try
        {
            ack = await GameLogic.Resign();
        }
        catch (InvalidOperationException e)
        {
            Notify(e.Message, Severity.Warning);
            return;
        }

        if (ack == (uint)AckTypes.Success) return;
        Notify("Failed to resign", Severity.Error);
    }

    private async void OfferDraw()
    {
        AckTypes ack;

        try
        {
            ack = await GameLogic.OfferDraw();
        }
        catch (InvalidOperationException e)
        {
            Notify(e.Message, Severity.Warning);
            return;
        }

        switch (ack)
        {
            case AckTypes.Success:
                Notify("Draw Offer Successful!", Severity.Info);
                return;
            case AckTypes.DrawOfferDeclined:
                Notify("Draw Offer Declined!", Severity.Info);
                break;
        }
    }

    private async void SendDrawResponse(bool accepted)
    {
        AckTypes ack;
        try
        {
            ack = await GameLogic.SendDrawResponse(accepted);
        }
        catch (InvalidOperationException e)
        {
            Notify(e.Message, Severity.Warning);
            return;
        }

        if (ack == AckTypes.Success)
        {
            StateHasChanged();
        }
        else
        {
            Notify($"Failed to send draw response! AckType = {ack}", Severity.Error);
        }
    }

    private void OnGameFirstJoined(JoinedGameStreamDto dto)
    {
        Enum.TryParse(GameLogic.OnWhiteSide ? "White" : "Black", out GameSides side);
        _isWhiteSide = side;
    }

    private void OnEndOfTheGameReached(JoinedGameStreamDto dto)
    {
        PlaySound("notify");
        switch (dto.GameEndType)
        {
            case (uint)GameEndTypes.CheckMate:
                if ((dto.IsWhite && GameLogic.OnWhiteSide) || (!dto.IsWhite && !GameLogic.OnWhiteSide))
                    DisplayDefaultDialog("You got checkmated!");
                else
                    DisplayDefaultDialog("You checkmated your opponent!");
                break;
            case (uint)GameEndTypes.Repetition:
                DisplayDefaultDialog("Draw by repetition!");
                break;
            case (uint)GameEndTypes.Pat:
                DisplayDefaultDialog("Stalemate!");
                break;
            case (uint)GameEndTypes.FiftyMove:
                DisplayDefaultDialog("Draw by 50 moves!");
                break;
            case (uint)GameEndTypes.MaterialDrawn:
                DisplayDefaultDialog("Draw! Insufficient material!");
                break;
        }
    }

    private void OnTimeUpdated(JoinedGameStreamDto dto)
    {
        if (dto.GameEndType == (uint)GameEndTypes.TimeIsUp)
        {
            if ((dto.IsWhite && GameLogic.OnWhiteSide) || (!dto.IsWhite && !GameLogic.OnWhiteSide))
            {
                DisplayDefaultDialog("You ran out of time! You loose!");
            }
            else
            {
                DisplayDefaultDialog("Your opponent ran out of time! You win!");
            }
        }
        else
        {
            if (dto.IsWhite)
            {
                _whiteSeconds = dto.TimeLeftMs / 1000;
                _whiteTimerActive = true;
            }
            else
            {
                _blackSeconds = dto.TimeLeftMs / 1000;
                _whiteTimerActive = false;
            }
            
            StateHasChanged();
        }
    }

    private void OnNewFenReceived(JoinedGameStreamDto dto)
    {
        SetFenPosition(dto.FenString);
        PlaySound("move");
    }

    private void SetFenPosition(string fen)
    {
        FenData fenData = new FenData(fen);
        State state = new State();
        _position.Set(in fenData, ChessMode.Normal, state);
        StateHasChanged();
    }

    private void OnResignationReceived(JoinedGameStreamDto dto)
    {
        PlaySound("notify");
        if ((dto.IsWhite && GameLogic.OnWhiteSide) || (!dto.IsWhite && !GameLogic.OnWhiteSide))
        {
            DisplayDefaultDialog("You resigned the game!");
        }
        else
        {
            DisplayDefaultDialog("Your opponent resigned the game!");
        }
    }

    private void OnInitialTimeReceived(JoinedGameStreamDto dto)
    {
        _opponentName = dto.UsernameWhite.Equals(_currentUser) ? dto.UsernameBlack : dto.UsernameWhite;
        PlaySound("notify");
        Notify("Game joined. Have fun!", Severity.Success);
        _whiteSeconds = dto.TimeLeftMs / 1000;
        _blackSeconds = dto.TimeLeftMs / 1000;
        StateHasChanged();
    }

    private void OnDrawOffered(JoinedGameStreamDto dto)
    {
        Notify($"Draw offer", Severity.Info);
        StateHasChanged();
    }

    private void OnDrawOfferTimedOut(JoinedGameStreamDto dto)
    {
        Notify("Draw offer expired", Severity.Info);
        StateHasChanged();
    }

    private void OnDrawOfferAccepted(JoinedGameStreamDto dto)
    {
        PlaySound("notify");
        DisplayDefaultDialog("The game finished in a draw!");
        StateHasChanged();
    }

    private void PlaySound(string sound)
    {
        Js.InvokeAsync<string>("PlaySound", new object[] { sound });
    }

    private void Notify(string message, Severity severity)
    {
        Snackbar.Add(message, severity);
    }

    private void DisplayDefaultDialog(string message)
    {
        var options = new DialogOptions { CloseOnEscapeKey = true };
        DialogService.Show<InformDialogComponent>(message, options);
    }

}