@page "/ChessGame"
@using Rudzoft.ChessLib.Types
@using StockfishWrapper
@using Grpc.Net.Client
@using GrpcService
@using HttpClients.ClientInterfaces
@using MudBlazor
@using Rudzoft.ChessLib
@using Rudzoft.ChessLib.Enums
@using Rudzoft.ChessLib.Fen
@using Application.LogicInterfaces
@using Game = GrpcService.Game
@using Position = Rudzoft.ChessLib.Position
@using Domain.DTOs
@using Domain.Enums
@using Grpc.Core
@using BlazorWASM.Pages.ChessComponents
@using System.Diagnostics
@inject GrpcChannel Channel
@inject IAuthService AuthService
@inject IDialogService DialogService
@inject IJSRuntime Js
@inject ISnackbar Snackbar
@inject IGameLogic GameLogic
@implements IDisposable


<h3 style="margin: 10px auto; text-align: center">ChessGame</h3>

<audio id="move" src="sounds/move.mp3"></audio>
<audio id="notify" src="sounds/notify.mp3"></audio>

<MudButton @onclick="OnResign" Variant="Variant.Filled" Color="Color.Primary">Resign</MudButton>
<MudButton @onclick="OnOfferDraw" Variant="Variant.Filled" Color="Color.Primary">Offer Draw</MudButton>
@if (IsDrawOfferPending)
{
    <div>
        <h3>You have a draw offer</h3>
        <MudButton @onclick="() => OnSendDrawResponse(true)" Variant="Variant.Filled" Color="Color.Success">Accept</MudButton>
        <MudButton @onclick="() => OnSendDrawResponse(false)" Variant="Variant.Filled" Color="Color.Error">Decline</MudButton>
    </div>
}

@code {

    private async void OnResign()
    {
        var user = await AuthService.GetAuthAsync();
        var isLoggedIn = user.Identity != null;

        if (!isLoggedIn) return;

        var token = AuthService.GetJwtToken();
        var headers = new Metadata { { "Authorization", $"Bearer {token}" } };
        var ack = await _client.ResignAsync(new RequestResign { Username = user.Identity!.Name, GameRoom = _gameRoomInt }, headers);

        if (ack.Status == (uint)AckTypes.Success) return;
        Notify("Failed to resign", Severity.Error);
    }

    private async void OnOfferDraw()
    {
        var user = await AuthService.GetAuthAsync();
        var isLoggedIn = user.Identity != null;

        if (!isLoggedIn) return;

        var token = AuthService.GetJwtToken();
        var headers = new Metadata { { "Authorization", $"Bearer {token}" } };
        var ack = await _client.OfferDrawAsync(new RequestDraw
        {
            Username = user.Identity!.Name, GameRoom = _gameRoomInt
        }, headers);

        switch (ack.Status)
        {
            case (uint)AckTypes.Success:
                Notify("Draw Offer Successful!", Severity.Info);
                return;
            case (uint)AckTypes.DrawOfferExpired:
                Notify("Draw Offer Expired!", Severity.Info);
                break;
            case (uint)AckTypes.DrawOfferDeclined:
                Notify("Draw Offer Declined!", Severity.Info);
                break;
        }
    }

    private async void OnSendDrawResponse(bool accepted)
    {
        var user = await AuthService.GetAuthAsync();
        var isLoggedIn = user.Identity != null;

        if (!isLoggedIn) return;

        var token = AuthService.GetJwtToken();
        var headers = new Metadata { { "Authorization", $"Bearer {token}" } };
        var ack = await _client.DrawOfferResponseAsync(new ResponseDraw
        {
            Username = user.Identity!.Name, GameRoom = _gameRoomInt, Accept = accepted
        }, headers);

        if (ack.Status == (uint)AckTypes.Success)
        {
            GameLogic.IsDrawOfferPending = false;
        }
        else
        {
            Notify($"Failed to send draw response! AckType = {ack.Status}", Severity.Error);
        }
    }

}

<MudGrid>
    <MudItem md="12" lg="6" Class="chess-board">
        <TimerComponent Active="@(_isWhiteSide ? !_whiteTimerActive : _whiteTimerActive)" Seconds="@(_isWhiteSide ? _blackSeconds : _whiteSeconds)"/>
        <ChessBoardComponent OnMoveMade="MakeMove" Position="@_position" IsWhiteSide="@_isWhiteSide"/>
        <TimerComponent Active="@(_isWhiteSide ? _whiteTimerActive : !_whiteTimerActive)" Seconds="@(_isWhiteSide ? _whiteSeconds : _blackSeconds)"/>
    </MudItem>
    <MudItem md="12" lg="6">
        <MudSelect Dense="true" T="string" @bind-Value="@_selectedLevel" Label="Choose a Stockfish Level:" Variant="Variant.Text">
            <MudSelectItem T="string" Value="@(StockfishLevels.StockfishAi1.Value)">Level 1</MudSelectItem>
            <MudSelectItem T="string" Value="@(StockfishLevels.StockfishAi2.Value)">Level 2</MudSelectItem>
            <MudSelectItem T="string" Value="@(StockfishLevels.StockfishAi3.Value)">Level 3</MudSelectItem>
            <MudSelectItem T="string" Value="@(StockfishLevels.StockfishAi4.Value)">Level 4</MudSelectItem>
            <MudSelectItem T="string" Value="@(StockfishLevels.StockfishAi5.Value)">Level 5</MudSelectItem>
            <MudSelectItem T="string" Value="@(StockfishLevels.StockfishAi6.Value)">Level 6</MudSelectItem>
            <MudSelectItem T="string" Value="@(StockfishLevels.StockfishAi7.Value)">Level 7</MudSelectItem>
            <MudSelectItem T="string" Value="@(StockfishLevels.StockfishAi8.Value)">Level 8</MudSelectItem>
        </MudSelect>
        <MudRadioGroup @bind-SelectedOption="_isWhiteSide" T="bool">
            <MudRadio T="bool" Color="Color.Default" Option="true">White</MudRadio>
            <MudRadio T="bool" Color="Color.Dark" Option="false">Black</MudRadio>
        </MudRadioGroup>
        <MudNumericField T="ulong" @bind-Value="_gameRoomInt" Label="Room id" Variant="Variant.Text" Min="0"/>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" @onclick="JoinGame">Join</MudButton>
        <MudRadioGroup @bind-SelectedOption="_chosenGameType" T="string">
            <MudRadio T="string" Color="Color.Default" Option=@("AI")>AI</MudRadio>
            <MudRadio T="string" Color="Color.Default" Option=@("Friend")>Friend</MudRadio>
            <MudRadio T="string" Color="Color.Default" Option=@("Random")>Random</MudRadio>
        </MudRadioGroup>
        <MudTextField T="string" Label="Opponent" Required="true" RequiredError="User name is required!" @bind-Value="_opponent"/>
        <MudNumericField T="uint" @bind-Value="_timeControlBase" Label="Base time" Variant="Variant.Filled" Min="60"/>
        <MudNumericField T="uint" @bind-Value="_timeControlIncrement" Label="Increment time" Variant="Variant.Filled" Min="0"/>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" @onclick="CreateGame">Create game</MudButton>
    </MudItem>
</MudGrid>

@code {

    private Game.GameClient _client;
    private readonly IPosition _position = new Position(new Board(), new PieceValue());
    private double _whiteSeconds;
    private double _blackSeconds;
    private bool _whiteTimerActive = true;
    private bool IsDrawOfferPending => GameLogic.IsDrawOfferPending;

    //Form input bindings
    private string _selectedLevel = StockfishLevels.StockfishAi1.Value;
    private string _chosenGameType = "AI";
    private ulong _gameRoomInt;
    private bool _isWhiteSide = true;
    private string _opponent = "";
    private uint _timeControlBase = 120;
    private uint _timeControlIncrement;


    protected override void OnInitialized()
    {
        _client = new Game.GameClient(Channel);
        SetFenPosition(Fen.StartPositionFen);
        InitGameLogic();
    }

    public void Dispose()
    {
        GameLogic.TimeUpdated -= OnTimeUpdated;
        GameLogic.NewFenReceived -= OnNewFenReceived;
        GameLogic.ResignationReceived -= OnResignationReceived;
        GameLogic.InitialTimeReceived -= OnInitialTimeReceived;
        GameLogic.DrawOffered -= OnDrawOffered;
        GameLogic.DrawOfferTimedOut -= OnDrawOfferTimedOut;
        GameLogic.DrawOfferAccepted -= OnDrawOfferAccepted;
    }

    private void InitGameLogic()
    {
        GameLogic.TimeUpdated += OnTimeUpdated;
        GameLogic.NewFenReceived += OnNewFenReceived;
        GameLogic.ResignationReceived += OnResignationReceived;
        GameLogic.InitialTimeReceived += OnInitialTimeReceived;
        GameLogic.DrawOffered += OnDrawOffered;
        GameLogic.DrawOfferTimedOut += OnDrawOfferTimedOut;
        GameLogic.DrawOfferAccepted += OnDrawOfferAccepted;
    }

    private async Task CreateGame()
    {
        string opponent = String.Empty;
        try
        {
            opponent = _chosenGameType switch 
            {
                "AI" => _selectedLevel,
                "Friend" => _opponent,
                "Random" => String.Empty,
                _ => throw new ArgumentNullException()
                };
        }
        catch (ArgumentNullException)
        {
            Notify("Choose a game type before starting a game!", Severity.Warning);
        }

        var request = new RequestGameDto
        {
            GameType = _chosenGameType,
            Increment = _timeControlIncrement,
            IsWhite = _isWhiteSide,
            Opponent = opponent,
            Seconds = _timeControlBase,
            Username = String.Empty // is set in game logic
        };

        try
        {
            var response = await GameLogic.CreateGame(request);

            _gameRoomInt = response.GameRoom;
    //TODO why do we set the time control on game creation and not game join?
    //TODO actually I think we do both, why?
            _whiteSeconds = _timeControlBase;
            _blackSeconds = _timeControlBase;

            Notify($"Game created successfully! Game id: {response.GameRoom}", Severity.Success);
        }
        catch (InvalidOperationException)
        {
            Notify("You have to be logged in to create a game!", Severity.Warning);
        }
        catch (HttpRequestException)
        {
            Notify("Network error, Failed to create a game.", Severity.Error);
        }
    }

    private async Task JoinGame()
    {
        try
        {
            GameLogic.JoinGame(new RequestJoinGameDto
            {
                GameRoom = _gameRoomInt,
                Username = "Bob"
            });
        }
        catch (ArgumentException)
        {
    //TODO: This catch will never catch anything cause there is no error thrown. New grpc message is needed
            Notify("Game room not found.", Severity.Warning);
        }
        catch (RpcException)
        {
            Notify("Connection error. Failed to participate in game. ¯\\_(ツ)_/¯", Severity.Error);
        }
    }

    private void OnTimeUpdated(JoinedGameStreamDto dto)
    {
        if (dto.IsWhite) _whiteSeconds = dto.TimeLeftMs / 1000;
        else _blackSeconds = dto.TimeLeftMs / 1000;
        StateHasChanged();
    }

    private void OnNewFenReceived(JoinedGameStreamDto dto)
    {
        SetFenPosition(dto.FenString);
        PlaySound("move");
    }

    private void SetFenPosition(string fen)
    {
        FenData fenData = new FenData(fen);
        State state = new State();
        _position.Set(in fenData, ChessMode.Normal, state);
        StateHasChanged();
    }

    private void OnResignationReceived(JoinedGameStreamDto dto)
    {
        PlaySound("notify");
        var options = new DialogOptions { CloseOnEscapeKey = true };
        if ((dto.IsWhite && GameLogic.OnWhiteSide) || (!dto.IsWhite && !GameLogic.OnWhiteSide))
        {
            DialogService.Show<InformDialogComponent>("You resigned the game!", options);
        }
        else
        {
            DialogService.Show<InformDialogComponent>("Your opponent resigned the game!", options);
        }
    }

    private void OnInitialTimeReceived(JoinedGameStreamDto dto)
    {
        PlaySound("notify");
        Notify("Game joined. Have fun!", Severity.Success);
        _whiteSeconds = dto.TimeLeftMs / 1000;
        _blackSeconds = dto.TimeLeftMs / 1000;
        StateHasChanged();
    }

    private void OnDrawOffered(JoinedGameStreamDto dto)
    {
        Notify("Opponent received draw offer.", Severity.Info);
    }

    private void OnDrawOfferTimedOut(JoinedGameStreamDto dto)
    {
        Notify("Draw offer expired", Severity.Info);
    }

    private void OnDrawOfferAccepted(JoinedGameStreamDto dto)
    {
        PlaySound("notify");
        var opt = new DialogOptions { CloseOnEscapeKey = true };
        DialogService.Show<InformDialogComponent>("The game finished in a draw!", opt);
    }

    public async Task<int> MakeMove(Move move)
    {
        return await GameLogic.MakeMove(move);
    }

    private void PlaySound(string sound)
    {
        Js.InvokeAsync<string>("PlaySound", new object[] { sound });
    }

    private void Notify(string message, Severity severity)
    {
        Snackbar.Add(message, severity);
    }

}