@page "/ChessGame"
@using BlazorWASM.Pages.ChessComponents
@using Grpc.Core
@using Grpc.Net.Client
@using GrpcService
@using HttpClients.ClientInterfaces
@using MudBlazor
@using Rudzoft.ChessLib
@using Rudzoft.ChessLib.Enums
@using Rudzoft.ChessLib.Fen
@using Rudzoft.ChessLib.Types
@using Game = GrpcService.Game
@using System.Security.Claims
@using Domain.Enums
@inject GrpcChannel Channel
@inject IAuthService AuthService
@using Position = Rudzoft.ChessLib.Position
@inject IDialogService DialogService

<h3 style="margin: 10px auto; text-align: center">ChessGame</h3>

<MudButton @onclick="OnResign" Variant="Variant.Filled" Color="Color.Primary">Resign</MudButton>
<MudButton @onclick="OnOfferDraw" Variant="Variant.Filled" Color="Color.Primary">Offer Draw</MudButton>
<label>@(_drawResult)</label>
@if (_isDrawOfferPending)
{
    <div>
        <h3>You have a draw offer</h3>
        <MudButton @onclick="() => OnSendDrawResponse(true)" Variant="Variant.Filled" Color="Color.Success">Accept</MudButton>
        <MudButton @onclick="() => OnSendDrawResponse(false)" Variant="Variant.Filled" Color="Color.Error">Decline</MudButton>
    </div>
}
<label>@(_drawResponseError)</label>

@code {
    private string _drawResult = string.Empty;
    private string _drawResponseError = string.Empty;

    private async void OnResign()
    {
        var user = await AuthService.GetAuthAsync();
        var isLoggedIn = user.Identity != null;

        if (!isLoggedIn) return;

        var token = AuthService.GetJwtToken();
        var headers = new Metadata {{"Authorization", $"Bearer {token}"}};
        var ack = await _client.ResignAsync(new RequestResign() { Username = user.Identity!.Name, GameRoom = _gameRoomInt }, headers);

        if (ack.Status == (uint)AckTypes.Success) return;
        DialogService.Show<InformDialogComponent>("Failed to resign", new DialogOptions() { CloseOnEscapeKey = true });
    }

    private async void OnOfferDraw()
    {
        var user = await AuthService.GetAuthAsync();
        var isLoggedIn = user.Identity != null;

        if (!isLoggedIn) return;

        var token = AuthService.GetJwtToken();
        var headers = new Metadata {{"Authorization", $"Bearer {token}"}};
        var ack = await _client.OfferDrawAsync(new RequestDraw()
        {
            Username = user.Identity!.Name, GameRoom = _gameRoomInt
        }, headers);

        switch (ack.Status)
        {
            case (uint)AckTypes.Success:
                _drawResult = "Draw Offer Successful!";
                return;
            case (uint)AckTypes.DrawOfferExpired:
                _drawResult = "Draw Offer Expired!";
                break;
            case (uint)AckTypes.DrawOfferDeclined:
                _drawResult = "Draw Offer Declined!";
                break;
        }
    }

    private async void OnSendDrawResponse(bool accepted)
    {
        var user = await AuthService.GetAuthAsync();
        var isLoggedIn = user.Identity != null;

        if (!isLoggedIn) return;

        var token = AuthService.GetJwtToken();
        var headers = new Metadata {{"Authorization", $"Bearer {token}"}};
        var ack = await _client.DrawOfferResponseAsync(new ResponseDraw()
        {
            Username = user.Identity!.Name, GameRoom = _gameRoomInt, Accept = accepted
        
        }, headers);

        if (ack.Status == (uint)AckTypes.Success)
        {
            _isDrawOfferPending = false;
        }
        else
        {
            _drawResponseError = "Failed to send draw response! AckType = " + ack.Status;
        }
    }
}

<MudGrid>
    <MudItem md="12" lg="6" Class="chess-board">
        <TimerComponent Active="@(_isWhiteSide ? !_whiteTimerActive : _whiteTimerActive)" Seconds="@(_isWhiteSide ? _blackSeconds : _whiteSeconds)"/>
        <ChessBoardComponent OnMoveMade="MakeMove" Position="@_position" IsWhiteSide="@_isWhiteSide"/>
        <TimerComponent Active="@(_isWhiteSide ? _whiteTimerActive : !_whiteTimerActive)" Seconds="@(_isWhiteSide ? _whiteSeconds : _blackSeconds)"/>
    </MudItem>
    <MudItem md="12" lg="6">
    <MudSelect Dense="true" T="int" @bind-Value="@_selectedLevel" Label="Choose a Stockfish Level:" Variant="Variant.Text">
        <MudSelectItem T="int" Value="1">Level 1</MudSelectItem>
        <MudSelectItem T="int" Value="2">Level 2</MudSelectItem>
        <MudSelectItem T="int" Value="3">Level 3</MudSelectItem>
        <MudSelectItem T="int" Value="4">Level 4</MudSelectItem>
        <MudSelectItem T="int" Value="5">Level 5</MudSelectItem>
        <MudSelectItem T="int" Value="6">Level 6</MudSelectItem>
        <MudSelectItem T="int" Value="7">Level 7</MudSelectItem>
    </MudSelect>
    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(_stockfishActivated)" @onclick="PlayStockfish">Play</MudButton>
    <MudRadioGroup @bind-SelectedOption="_isWhiteSide" T="bool">
        <MudRadio T="bool" Color="Color.Default" Option="true">White</MudRadio>
        <MudRadio T="bool" Color="Color.Dark" Option="false">Black</MudRadio>
    </MudRadioGroup>
    <MudNumericField  T="ulong" @bind-Value="_gameRoomInt" Label="Room id" Variant="Variant.Text" Min="0"/>
    <MudButton Variant="Variant.Filled" Color="Color.Primary" @onclick="JoinGame">Join</MudButton>
    <MudTextField T="string" Label="Opponent" Required="true" RequiredError="User name is required!" @bind-Value="_opponent"/>
    <MudNumericField T="uint" @bind-Value="_timeControlBase" Label="Base time" Variant="Variant.Filled" Min="60"/>
    <MudNumericField T="uint" @bind-Value="_timeControlIncrement" Label="Increment time" Variant="Variant.Filled" Min="0"/>
    <MudButton Variant="Variant.Filled" Color="Color.Primary" @onclick="CreateGame">Create game</MudButton>
    </MudItem>
</MudGrid>
@code {

    private Game.GameClient _client;
    private IPosition _position = new Position(new Board(), new PieceValue());

    private int _selectedLevel = 1;
    private bool _stockfishActivated;

    private bool _isWhiteSide = true;
    private ulong _gameRoomInt = 0;

    private double _whiteSeconds;
    private double _blackSeconds;

    private string _opponent = "StockfishAi";

    private bool _whiteTimerActive = true;
    private uint _timeControlBase = 60, _timeControlIncrement = 0;

    private bool _isDrawOfferPending = false;

    protected override void OnInitialized()
    {
        _client = new Game.GameClient(Channel);
    }

    public ChessGame()
    {
        SetFenPosition(Fen.StartPositionFen);
    }

    private async Task CreateGame()
    {
        ClaimsPrincipal user = await AuthService.GetAuthAsync();
        var isLoggedIn = user.Identity != null;

        if (!isLoggedIn) return;

        _whiteSeconds = _timeControlBase;
        _blackSeconds = _timeControlBase;
        var responseGame = await _client.StartGameAsync(new RequestGame()
        {
            GameType = "AI",
            Increment = _timeControlIncrement,
            IsWhite = _isWhiteSide,
            Opponent = _opponent,
            Seconds = _timeControlBase,
            Username = user.Identity!.Name!
        });
        _gameRoomInt = responseGame.GameRoom;
    }

    private async Task JoinGame()
    {
        var call = _client.JoinGame(new RequestJoinGame()
        {
            GameRoom = _gameRoomInt,
            Username = "Bob"
        });

        while (await call.ResponseStream.MoveNext(CancellationToken.None))
        {
            var message = call.ResponseStream.Current;
            Console.WriteLine("Event: " + message.Event);

            switch (message.Event)
            {
                case "TimeUpdate":
                    if (message.GameEndType != (uint)GameEndTypes.TimeIsUp)
                    {
                        UpdateTimers(message.IsWhite, message.TimeLeftMs);
                    }
                    break;
                case "NewFenPosition":
                    _whiteTimerActive = !_whiteTimerActive;
                    SetFenPosition(message.Fen);
                    break;
                case "Resignation":
                {
                    var options = new DialogOptions { CloseOnEscapeKey = true };
                    if ((message.IsWhite && _isWhiteSide) || (!message.IsWhite && !_isWhiteSide))
                    {
                        DialogService.Show<InformDialogComponent>("You resigned the game!", options);
                    }
                    else
                    {
                        DialogService.Show<InformDialogComponent>("Your opponent resigned the game!", options);
                    }
                    break;
                }
                case "DrawOffer":
                    if (!(message.IsWhite && _isWhiteSide) && !(!message.IsWhite && !_isWhiteSide))
                        _isDrawOfferPending = true;
                    break;
                case "DrawOfferTimeout":
                    _isDrawOfferPending = false;
                    break;
                case "DrawOfferAccepted":
                    _isDrawOfferPending = false;
                    var opt = new DialogOptions { CloseOnEscapeKey = true };
                    DialogService.Show<InformDialogComponent>("The game finished in a draw!", opt);
                    break;
                case "InitialTime":
                    _whiteSeconds = message.TimeLeftMs / 1000;
                    _blackSeconds = message.TimeLeftMs / 1000;
                    break;
            }

            StateHasChanged();
        }
    }

    private void UpdateTimers(bool white, double seconds)
    {
        if (white) _whiteSeconds = seconds / 1000;
        else _blackSeconds = seconds / 1000;
    }

    private void SetFenPosition(string fen)
    {
        FenData fenData = new FenData(fen);
        State state = new State();
        _position.Set(in fenData, ChessMode.Normal, state);
    }

    public async Task<int> MakeMove(Move move)
    {
        var token = AuthService.GetJwtToken();
        var headers = new Metadata {{"Authorization", $"Bearer {token}"}};
        var call = await _client.MakeMoveAsync(new RequestMakeMove()
        {
            FromSquare = move.FromSquare().ToString(),
            ToSquare = move.ToSquare().ToString(),
            GameRoom = _gameRoomInt,
            MoveType = (uint) move.MoveType(),
            Promotion = (uint) move.PromotedPieceType().AsInt()
        }, headers);
        return (int) call.Status;
    }

    public void PlayStockfish()
    {
        if (_selectedLevel is > 0 and < 9)
            _stockfishActivated = true;
    }

}